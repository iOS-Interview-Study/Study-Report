# Delegate vs Notification

앱에서 발생한 이벤트가 현재 화면이 아닌 다른 화면까지 영향을 주어야할 때 Delegate과 Notification 중 선택해서 사용하는 것이 대부분이다. (외부 라이브러리의 도움은 받지 않는다고 가정)

Delegate와 Notification 방식은 결과는 같지만 그 과정이 조금 다르다. 오늘은 이 두가지 방법의 공통점과 차이점에 대해 공부해보았다.



### 공통점

Delegate, Notification 모두 어떤 이벤트를 다른 화면에 전달할 수 있다는 기능을 가진다. Delegate 패턴은 다른 객체의 인스턴스를 내부적으로 보유하여 그 인스턴스를 활용하는 방식으로 운용되며, Notification은 어떤 객체를 Observing하여 그 객체의 변화에 따라 Observer들이 이벤트를 받아 처리할 수 있는 방식으로 운용된다.

일반적으로 `SomeDelegate`과 같은 꼴로 쓰이는 delegate은 전자의 경우라면 SomeDelegate을 가진 객체는 Some의 이벤트를 전달받아 이벤트를 처리하는 역할을 한다. 외부에 있는 Some 객체에서 접근할 수 없는 내부 요소의 수정, 이벤트의 시작이 이루어지는 경우 보통 사용한다.

Notification의 경우에는 어떤 값의 변화에 따라 어떤 이벤트 (프로퍼티의 변화, 함수의 trigger)가 발생해야할 때 이를 observe 하고 있다가 실행하는 구조이다. 

두 방식 모두 `값의 변화`를 포착하여 `이벤트`를 발생시킨다는 공통점을 가지고 있다.



### 차이점

가장 큰 차이점은 Notification과 다르게 Delegate의 경우에는 수신자가 발신자의 정보를 알고 있어야한다는 것이다.

SomeDelegate에서 SomeDelegate을 가진 객체는 SomeDelegate protocol의 메서드로 이벤트가 발생했을 때 처리해줄 수 있는 메서드를 요구함으로써 SomeDelegate을 가진 객체가 이벤트를 처리할 수 있도록 해준다.

즉, SomeDelegate protocol을 제작할 때 메서드의 틀을 미리 잡아놓아야하며 SomeDelegate이라는 변수를 이벤트 처리 담당 객체가 들고 있어야 한다. 하지만 Notification의 경우에는 이 과정이 무의미하다. 단순히 어떤 값의 변화를 포착하여 그에 맞는 이벤트를 발생시켜주면 된다. 

장점으로도 보이는 이 특징은 양날의 검과 같다. Delegate을 사용하여 설계하지 않고 Notification만 가지고 설계를 했다면 다른 사람이 코드를 유지보수할 때 이 Notification을 누가 Subscribe하고 있는지 알기가 어렵다. 반면 Delegate으로 설계를 했다면 해당 Delegate의 이름, 프로토콜의 메서드 등을 통해 어떤 과정에 의해 이벤트 처리 로직이 돌아가는지 파악하기 한결 수월하다.


# Hugging vs Resistance

hugging은 말 그대로 안고있으려는 힘이다. 조금 덧붙이자면 더이상 늘어나지 않으려는 힘을 hugging이라고 한다. stackView의 distribution 속성이 fill일 경우 내부의 요소들은 stackView 안에서 멋대로 늘어난다. 이 때 hugging priority가 높다면 늘어나지 않고 intrinsic size를 유지하려하고, 낮다면 늘어난다.



resistance는 눌리지 않으려는 힘이다. 화면에 담을 수 없는 크기의 요소들을 우겨넣으면 어떤 요소는 필연적으로 줄어들거나 가려져야한다. 이 때 resistance priority가 낮은 요소부터 줄어들거나 가려지기 시작한다.

# AR

Automatic Retain Count의 약자인 ARC는 자동으로 참조카운트를 계산해주는 swift의 기능을 뜻한다.

이름을 통해 유추할 수 있듯 기존에는 자동으로 참조 카운트를 계산하여 메모리로부터 해제해주지 않았기에 프로그래머가 직접 사용을 끝마친 포인터를 메모리에서 해제시켜줘야 했었다.

하지만 ARC를 통해 이제는 참조를 획득하는 과정과 메모리에서 해제하는 과정이 자동으로 이루어진다. (뒷단에서 벌어지는 일이기에 눈에는 보이지 않지만 필요이상의 작업이 이루어지고 있을수도 있다. 이를 방지하기 위해 참조에 대한 이해를 바탕으로 코드를 작성해야 한다.)



## Retain Count 왜 필요할까?

포인터는 흔히 주소에 비유한다. 어떤 음식점의 주소를 미리 알고 있던 사람이 음식점에 가기 위해선 음식점의 주소로 이동하면 된다. 근데 만약 음식점이 사라져있다면 곤란할 것이다.

프로그래밍에서도 마찬가지이다 주소값을 통해 접근한 위치에 쓰레기값이 존재하면 언어에 따라 오류를 내는 언어도 있고 쓰레기값을 그대로 가져오는 언어도 있을 것이다. 두 경우 모두 프로그래머의 의도에 벗어난 결과라는 것을 쉽게 알 수 있다.

이런 상황을 방지하기 위해서 Retain Count라는 것이 필요하다. 음식점의 주소를 알고있는 사람이 있다면 그 사람의 수를 세어서 음식점이 보관한다. 만약 음식점의 주소를 알고있는 사람의 수가 0보다 크면 음식점을 계속 유지시키는 개념이다.

힙 영역에 존재하는 값이 필요한 동안에 반드시 사라지지 않는 것을 보장해준다고 생각하면 이해가 쉬울 것 같다.



## Retain Cycle은 뭘까?

Retain Count를 통해 "필요한 동안 반드시" 값이 살아있음을 보장받을 수 있단 사실을 알게되었다. 하지만 그 반대의 경우는 어떠할까? "(메모리 공간확보를 위해서) 이제 없어져야 하는" 값이 반드시 적절한 시점에 메모리에서 해제될 것이라는 보장은 하지 못했다. 이런 상황을 메모리 누수가 발생했다 말하며 프로그래머로서 이런 상황을 피해야하는 것이 당연하다.

Retain Cycle을 발생시키는 경우에 대해서 더 자세히 알고싶다면 [이 레포지토리](https://github.com/godrm/RetainCycleApp)를 참고해보면 좋을 것 같다.


# inActive 상태란?

앱의 생명주기는 크게 아래와 같이 나뉜다.

1. not running
2. foreground
   1. inActive
   2. active
3. background
4. Suspended



not running은 말 그대로 앱이 실행중이지 않은 상태이며

앱 실행시 foreground 상태로 진입한다 (background 상태에서도 진입 가능)

이 때 active 상태로 가기 전 inActive상태를 거치게 된다.

Suspended 상태는 메모리의 공간확보 문제로 iOS가 임의로 메모리에서 해제시키는 상태를 말한다.

이 때 앱은 not running 상태로 돌아간다. 
